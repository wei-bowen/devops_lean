## 向容器传递参数
### 实验准备
>准备一个需要传入参数的镜像luksa/fortune:args
写一个脚本，调用fortune程序定时往一个文件写一句外国名言
```shell
#!/bin/bash
trap "exit" SIGINT
INTERVAL=$1
echo "Configured to generate new fortune every $INTERVAL seconds"
mkdir -p /var/htdocs
while :
do 
   echo $(date) Writing fortune to /var/htdocs/index.html
   /usr/bin/fortune > /var/htdocs/index.html
   sleep $INTERVAL
done
```
再建一个Docker镜像，基于乌班图，安装好fortune程序，然后按照传入的时间间隔执行上面哪个脚本。
```groovy
FROM ubuntu
RUN apt-get update ; apt-get -y install fortune
ADD fortuneloop.sh /bin/fortuneloop.sh
ENTRYPOINT ["/bin/fortuneloop.sh"]
CMD ["10"]
```
以上的脚本是为了帮助理解原理，实际操作直接下载镜像luksa/fortune:args即可 <br>
执行`docker run -it luksa/fortune:args`就能看到每隔10秒写名言
```shell
[root@k8s-master ~]# docker run -it luksa/fortune:args
Unable to find image 'luksa/fortune:args' locally
args: Pulling from luksa/fortune
.....
Configured to generate new fortune every 10 seconds
Mon Sep 21 12:58:34 UTC 2020 Writing fortune to /var/htdocs/index.html
Mon Sep 21 12:58:44 UTC 2020 Writing fortune to /var/htdocs/index.html
.....
```
>再准备一个直接从系统变量中读取参数的镜像luksa/fortune:env
相比上面的镜像，删除了`INTERVAL=$1`,即不再主动传入参数。
```shell
#!/bin/bash
trap "exit" SIGINT
echo "Configured to generate new fortune every $INTERVAL seconds"
mkdir -p /var/htdocs
while :
do 
   echo $(date) Writing fortune to /var/htdocs/index.html
   /usr/bin/fortune > /var/htdocs/index.html
   sleep $INTERVAL
done
```
### 1、Pod建立时传入参数
上面建立的容器默认是10秒打印一句名言，我们可以在定义Pod可以将docker镜像的ENTRYPOINT和CMD覆盖，格式如下
```yaml
......
spec:
  containers:
  - image: luksa/fortune:args
    command: ["/bin/command"]                       ##等同于ENTRYPOINT
    args: ["args1","args2","args3"]                 ##等同于CMD，采用上面的列表形式也可
```
操作中我们只要指定args，即可实现15秒打印一次名言警句
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: fortune15s
spec:
  containers:
  - image: luksa/fortune:args
    args: ["15"]                  ##args 传入参数即可如果要传入多个参数 则是   args:
    name: html-generator                                                    - args1
    volumeMounts:                                                           - args2
    ....                                                                    - .....
     ...
```
### 2、为容器设置环境变量
Pod定义时传入环境变量，代码如下：
```yaml
spec:
  containers:
  - image: luksa/fortune:env
    name: html-generator
    env:
    - name: INTERVAL
      value: 30                                 ##在这里把环境变量定义进去。多个变量多个- 写入
    - name: time
      value: "$(INTERVAL)s"                     ##引用其他环境变量，这样time="30s"  此处是多余的，只是演示知识点
    ....
```
### 3、利用ConfigMap传递参数
将配置选项以键值对(key:value、key:file、key:folder)的形式分离到单独的资源对象ConfigMap。内容会传给容器，命令行参数可以通过$(env_var)语法引用<br>
- 从命令行创建ConfigMap<br>
`kubectl create configmap fortune-config --from-literal=sleep_interval=15 --from-literal=env=delevop --dry-run=client -o yaml`
```yaml
apiVersion: v1
data:
  env: delevop
  sleep_interval: "15"
kind: ConfigMap
metadata:
  name: fortune-config
```
- 从文件内容创建ConfigMap条目<br>
`kubectl create configmap fortune-config --from-file=sleep_interval=my.cnf --dry-run=client -o yaml`
```yaml
apiVersion: v1
data:
  sleep_interval: |                          ##"|"号后面是文件内容
    sleep_interval:3
kind: ConfigMap
metadata:
  name: fortune-config
```
可以多次使用 --from-file引入多个条目。 如果后面接的是文件夹，就会一次性引入文件夹下的所有文件 文件名: | <换行>文件内容 <br>
也可以在命令行中同时使用 --from-file和 --from-literal <br>
注意：键名只能包含数字、字母、下划线、破折号、圆点
- 在Pod中引用ConfigMap
```yaml
spec:
  containers:
  - image: luksa/fortune:env
    env:
    - name: INTERVAL
      valueFrom:
        configMapKeyRef:               ##使用ConfigMap记录值进行初始化，不设固定值
          name: fortune-config         ##引用的ConfigMap名称
          key: sleep-interval          ##对应的键
          optional: true               ##键值不存在也启动。不指定该选项则默认false
    args: [$INTERVAL]
```
- 一次性引用所有条目
```yaml
spec:
  containers:
  - image: luksa/fortune:env           
    envFrom:
    - prefix: CONFIG_                  ##前缀可以不指定，指定后ConfigMap中的env将被当成CONFIG_env被引入，而CONFIG_sleep-interval将因为含有破折号不是合法环境变量而被丢弃
      configMapKeyRef:
        name: fortune-config
```
- 展示ConfigMap内容
```shell
kubectl get configmap fortune-config -o yaml             ##
```
- 将ConfigMap中的条目暴露成文件。<br>
例如
```shell
date > index.html       ##当前时间写入文件
kubectl create configmap index-config --from-file=index.html ##将index.html写入ConfigMap
```
创建Pod对index.hrml进行引用
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test
spec:
  containers:
  - image: nginx:alpine
    name: webserver
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: true
    ports:
    - containerPort: 80
      protocol: TCP
  volumes:
  - name: html
    configMap:                         ##将config当成卷进行挂载
      name: index-config
```
**注意：挂载次index.html会默认隐藏原来的文件，挂载目录也会隐藏原来的目录。**<br>
此时访问Pod就可以看到index.html文件中的内容，即时间。
- 当ConfigMap中包含多条，我们只想挂载指定条目，可以
```
  volumes:
  - name: html
    configMap: 
      name: index-config
      defaultMode: "6600"        ##可以指定挂载文件的权限
      items:
      - key: index.html
        path: index.htm          ##允许将键值重定向到新的文件中进行挂载
```
- 更新配置不重启应用
```shell
date > index.html
kubectl delete configmaps index-config
kubectl create configmap index-config --from-file=index.html         ##删除重建ConfigMap，也可以直接edit 它
exec -it test -c webserver -- nginx -s reload                        ##通知容器reload nginx
##此时再看首页就变了
```
>**使用Secret给容器传递敏感配置**。
- secret结构类似ConfigMap，也是键值对，方法也类似
- secret在master节点是非加密存储。但是在node节点中是加密存储在内存中
- 每个Pod都挂载了一个默认的Secret
```
 kubectl describe pod fortune                                           ##随便找个Pod查看以下，可以看到一个SecretName:  default-token-****的挂载，也可以看到其挂载位置
                                                                        ##/var/run/secrets/kubernetes.io/serviceaccount from default-token-6zwxv
kubectl exec fortune ls /var/run/secrets/kubernetes.io/serviceaccount   ##即可看到目录下 ca.crt、namespace、token三个文件
kubctl get secrets                                                      ##也可以看到这个default-token-**** 的secret
kubectl describe secret default-token-6zwxv                             ##查看这个secrets即可看到三个条目，ca.crt、namespace、token. 包含了从Pod从内部访问k8sAPI服务器所需的全部信息
```
>**实操应用secret**
- 1、生成证书，让nginx能够使用HTTPS：
```shell
mkdir nginx-https && cd nginx-https
openssl genrsa -out https.key 2048
openssl req -new -x509 -key https.key -out https.cert -days 3650 -subj /CN=www.kubia-example.com
echo bar > foo       ##额外创建一个文件，为了对比
```
- 2、创建secret
```
kubectl create secret generic fortune-https --from-file=https.key --from-file=https.cert --from-file=foo
```
查看创建好的secret`kubectl create secret generic fortune-https --from-file=https.key --from-file=https.cert --from-file=foo --dry-run=client -o yaml`
可以看到都是被Base64编码加密存储
```yaml
apiVersion: v1
data:
  foo: YmFyCg==
  https.cert: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURFekNDQWZ1Z0F3SUJBZ0lKQU5BY2c0a2E5RDROTUEwR0N......
  https.key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcEFJQkFBS0NBUUVBcVdnSWczdmx0cTViQTBFa3Qx......
kind: Secret
metadata:
  creationTimestamp: null
  name: fortune-https
```
- 3、在Pod中使用secret,类似ConfigMAp
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-https
spec:
  containers:
  - iamge: luksa/fortune:env
    volumeMounts:
    - name: certs
      mountPath: /etc/nginx/certs/
      readOnly: true
  volumes:
  - name： certs
    secret:
      secretName: fortune-https
```
